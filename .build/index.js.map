{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["\nimport { Driver } from './Driver';\nimport { Address } from './Address';\nimport { Deliveries } from './Deliveries';\n\nimport fs from 'fs';\nimport readline from 'readline';\n\n\nlet drivers: Driver[];\nconsole.log('Type the drivers file');\ndrivers = getFileContent('drivers.txt');\nconsole.log('Type the addresses file');\nlet addresses: Address[] = getFileContent('addresses.txt');\n/**\n * Constant to match VOWELS for the score algorithm.\n */\nconst REGEX_PATTERN_ONLY_VOWELS = /[aeiou]/gi;\n\n/**\n * Constant to match CONSONANTS for the score algorithm.\n */\nconst REGEX_PATTERN_ONLY_CONSONANTS = /[bcdfghjklmnpqrstvwxyz]/gi;\n\n/**\n * Constant of the drivers and addresses to which they are going to deliver\n */\nconst finalDeliveries: Deliveries[] = [];\n\naddresses = addresses.sort((a, b) => {\n  return a.name.length - b.name.length;\n});\n\n/**\n * Constant array of all possible permutations between addresses and drivers to get all scores\n */\nconst driversPossibleDeliveries:\n  { driver: string, addresses: { address: string, score: number }[] }[] = drivers.map(driver => {\n    let deliveries: any = addresses.map(address => {\n      return {\n        address: address.name,\n        score: getScore(address.name, driver.name)\n      };\n    })\n    return { driver: driver.name, addresses: deliveries };\n  });\n\n\naddresses.forEach(address => {\n  // variable to save the address with the highest score and driver\n  let maxShipmentPermutation = { driver: null, address: null, score: null };\n\n  // Checking all the permutations looking for the highest one with the actual driver.\n  driversPossibleDeliveries.forEach(delivery => {\n\n    // Looking for the actual address and which is the driver with the highest score\n\n    const actualDelivery: any = delivery.addresses.find(deliveryAddress => address.name == deliveryAddress.address);\n\n    // If we found a higher score than the actual for that address we are going to save it until we reach another one\n    if (actualDelivery.score > maxShipmentPermutation?.score\n      && !finalDeliveries.some(finalDelivery => finalDelivery.driver == delivery.driver || finalDelivery.address == actualDelivery.address)) {\n      maxShipmentPermutation = actualDelivery;\n      maxShipmentPermutation.driver = delivery.driver;\n\n    }\n  })\n\n  // Once found an address and a driver which have not been coupled yet, we are going to assign that driver to that address\n  if (!finalDeliveries.some(delivery => delivery.driver == maxShipmentPermutation.driver || delivery.address == maxShipmentPermutation.address)) {\n    finalDeliveries.push({ driver: maxShipmentPermutation.driver, address: maxShipmentPermutation.address, score: maxShipmentPermutation.score });\n    maxShipmentPermutation = null;\n  }\n});\n\n\n// Prints the final results\nconsole.log(finalDeliveries);\n\n/** #region This section calculates the address score according to the next conditions \n * - If the length of the shipment's destination street name is even, the base suitability scoreis the number of\n * VOWELS in the driver's name multiplied by 1.5.\n *\n * - If the length of the shipment's destination street name is odd, the base SS is the number of CONSONANTS \n * in the driver's name multiplied by 1\n *\n * - If the length of the shipment's destination street shares any common factors (besides 1) with the length of\n * the driver's name, the SS is increased by 50% above the base SS.\n */\nfunction getScore(addressName: string, driverName: string): number {\n  const score = evenLength(addressName, driverName);\n\n  const noSpacesAddress = addressName?.replace(/\\s/g, '');\n  const noSpacesDriver = driverName?.replace(/\\s/g, '')\n\n  const addressFactors = numberFactor(noSpacesAddress.length);\n  const driverFactors = numberFactor(noSpacesDriver.length);\n  const shouldIncreaseSS: boolean = addressFactors.some(digit => driverFactors.includes(digit));\n\n  return shouldIncreaseSS ? score * 1.5 : score;\n\n}\n\nfunction evenLength(addressName: string, driverName: string): number {\n  return addressName.length % 2 === 1 ? vowelScore(driverName) * 1.5\n    : consonantScore(driverName);\n}\n\nfunction vowelScore(driversName: string): number {\n  return driversName?.match(REGEX_PATTERN_ONLY_VOWELS)?.length ?? 0;\n}\n\nfunction consonantScore(driversName: string): number {\n  return driversName?.match(REGEX_PATTERN_ONLY_CONSONANTS)?.length ?? 0;\n}\n\nfunction numberFactor(size: number): number[] {\n  return Array.from(Array(size + 1), (_, i) => i + 2).filter(i => size % i === 0);\n}\n// #endregion\n\n/**\n * Function that gets the content of a file line by line and transforms it into an object\n */\nfunction getFileContent(fileName: string): Driver[] | Address[] {\n  try{\n    const content = fs.readFileSync(fileName, 'utf-8')\n      .split('\\n')\n      .filter(Boolean);\n    console.log(content);\n  \n    return content.map((result: string) => {\n      return { name: result }\n    });\n  }catch (error) {\n    console.log(error);\n    throw(error);\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAKA,gBAAe;AAIf,IAAI;AACJ,QAAQ,IAAI;AACZ,UAAU,eAAe;AACzB,QAAQ,IAAI;AACZ,IAAI,YAAuB,eAAe;AAI1C,MAAM,4BAA4B;AAKlC,MAAM,gCAAgC;AAKtC,MAAM,kBAAgC;AAEtC,YAAY,UAAU,KAAK,CAAC,GAAG,MAAM;AACnC,SAAO,EAAE,KAAK,SAAS,EAAE,KAAK;AAAA;AAMhC,MAAM,4BACoE,QAAQ,IAAI,YAAU;AAC5F,MAAI,aAAkB,UAAU,IAAI,aAAW;AAC7C,WAAO;AAAA,MACL,SAAS,QAAQ;AAAA,MACjB,OAAO,SAAS,QAAQ,MAAM,OAAO;AAAA;AAAA;AAGzC,SAAO,EAAE,QAAQ,OAAO,MAAM,WAAW;AAAA;AAI7C,UAAU,QAAQ,aAAW;AAE3B,MAAI,yBAAyB,EAAE,QAAQ,MAAM,SAAS,MAAM,OAAO;AAGnE,4BAA0B,QAAQ,cAAY;AAI5C,UAAM,iBAAsB,SAAS,UAAU,KAAK,qBAAmB,QAAQ,QAAQ,gBAAgB;AAGvG,QAAI,eAAe,QAAQ,kEAAwB,UAC9C,CAAC,gBAAgB,KAAK,mBAAiB,cAAc,UAAU,SAAS,UAAU,cAAc,WAAW,eAAe,UAAU;AACvI,+BAAyB;AACzB,6BAAuB,SAAS,SAAS;AAAA;AAAA;AAM7C,MAAI,CAAC,gBAAgB,KAAK,cAAY,SAAS,UAAU,uBAAuB,UAAU,SAAS,WAAW,uBAAuB,UAAU;AAC7I,oBAAgB,KAAK,EAAE,QAAQ,uBAAuB,QAAQ,SAAS,uBAAuB,SAAS,OAAO,uBAAuB;AACrI,6BAAyB;AAAA;AAAA;AAM7B,QAAQ,IAAI;AAYZ,kBAAkB,aAAqB,YAA4B;AACjE,QAAM,QAAQ,WAAW,aAAa;AAEtC,QAAM,kBAAkB,2CAAa,QAAQ,OAAO;AACpD,QAAM,iBAAiB,yCAAY,QAAQ,OAAO;AAElD,QAAM,iBAAiB,aAAa,gBAAgB;AACpD,QAAM,gBAAgB,aAAa,eAAe;AAClD,QAAM,mBAA4B,eAAe,KAAK,WAAS,cAAc,SAAS;AAEtF,SAAO,mBAAmB,QAAQ,MAAM;AAAA;AAI1C,oBAAoB,aAAqB,YAA4B;AACnE,SAAO,YAAY,SAAS,MAAM,IAAI,WAAW,cAAc,MAC3D,eAAe;AAAA;AAGrB,oBAAoB,aAA6B;AA5GjD;AA6GE,SAAO,kDAAa,MAAM,+BAAnB,mBAA+C,WAAU;AAAA;AAGlE,wBAAwB,aAA6B;AAhHrD;AAiHE,SAAO,kDAAa,MAAM,mCAAnB,mBAAmD,WAAU;AAAA;AAGtE,sBAAsB,MAAwB;AAC5C,SAAO,MAAM,KAAK,MAAM,OAAO,IAAI,CAAC,GAAG,MAAM,IAAI,GAAG,OAAO,OAAK,OAAO,MAAM;AAAA;AAO/E,wBAAwB,UAAwC;AAC9D,MAAG;AACD,UAAM,UAAU,kBAAG,aAAa,UAAU,SACvC,MAAM,MACN,OAAO;AACV,YAAQ,IAAI;AAEZ,WAAO,QAAQ,IAAI,CAAC,WAAmB;AACrC,aAAO,EAAE,MAAM;AAAA;AAAA,WAEX,OAAP;AACC,YAAQ,IAAI;AACZ,UAAM;AAAA;AAAA;",
  "names": []
}
